name: CI/CD Pipeline

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main, dev ]
    paths-ignore:
      - '**/*.md'
      - '**/*.txt'

permissions:
  contents: read
  security-events: write
  
env:
  NODE_VERSION: '20'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Stage 1: SAST Scan
  sast-scan:
    name: SAST Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run CodeQL Analysis
        uses: github/codeql-action/init@v3
        with:
          languages: javascript

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

      - name: Run Semgrep SAST
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/secrets
            p/react
            p/typescript

  # Stage 2: Code Linting
  code-linting:
    name: Code Linting
    runs-on: ubuntu-latest
    needs: sast-scan
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Run Prettier check
        run: npm run format:check

      - name: TypeScript type check
        run: npm run type-check

  # Stage 3: Docker Linting
  docker-linting:
    name: Docker Linting
    runs-on: ubuntu-latest
    needs: sast-scan
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Hadolint
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile
          failure-threshold: warning

  # Stage 4: Build
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [code-linting, docker-linting]
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ fromJSON(steps.meta.outputs.json).tags[0] }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: dist/
          retention-days: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CR_PAT }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,format=short
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          dockerfile: Dockerfile
          target: production
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Stage 5: Image Scan
  image-scan:
    name: Container Image Security Scan
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CR_PAT }}

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.image-tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run Snyk Container scan
        uses: snyk/actions/docker@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: ${{ needs.build.outputs.image-tag }}
          args: --severity-threshold=high
        continue-on-error: true

  # Stage 6: Unit Tests
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit:coverage

      - name: Upload test coverage
        uses: codecov/codecov-action@v4
        if: always()
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-unit-tests
          fail_ci_if_error: false

  # Stage 7: Integration Tests  
  # integration-tests:
  #   name: Integration Tests
  #   runs-on: ubuntu-latest
  #   needs: [build, unit-tests]
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Setup Node.js
  #       uses: actions/setup-node@v4
  #       with:
  #         node-version: ${{ env.NODE_VERSION }}
  #         cache: 'npm'

  #     - name: Install dependencies
  #       run: npm ci

  #     - name: Build application
  #       run: npm run build

  #     - name: Start application for integration tests
  #       run: npm run preview &
        
  #     - name: Wait for application to start
  #       run: |
  #         for i in {1..30}; do
  #           if curl -f http://localhost:4173 >/dev/null 2>&1; then
  #             echo "Application is ready!"
  #             break
  #           fi
  #           echo "Waiting for application to start... (attempt $i/30)"
  #           sleep 2
  #         done

  #     - name: Run integration tests
  #       run: npm run test:integration:coverage

  #     - name: Upload integration test coverage
  #       uses: codecov/codecov-action@v4
  #       if: always()
  #       with:
  #         file: ./coverage/lcov.info
  #         flags: integrationtests
  #         name: codecov-integration-tests
  #         fail_ci_if_error: false

  # Stage 8: Deploy
  # deploy:
  #   name: Deploy Application
  #   runs-on: ubuntu-latest
  #   needs: [build, image-scan, unit-tests, integration-tests]
  #   if: github.ref == 'refs/heads/main'
  #   environment: production
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Deploy to Production
  #       run: |
  #         echo "Deploying image: ${{ needs.build.outputs.image-tag }}"
  #         # Add your deployment logic here
  #         # Examples:
  #         # - Deploy to Kubernetes
  #         # - Deploy to AWS ECS
  #         # - Deploy to Azure Container Instances
  #         # - Update Helm charts
          
  #         # Example Kubernetes deployment:
  #         # kubectl set image deployment/vallena-web vallena-web=${{ needs.build.outputs.image-tag }}
          
  #         # Example Docker Compose deployment:
  #         # docker-compose pull && docker-compose up -d
          
  #         echo "Deployment completed successfully"

  #     - name: Update deployment status
  #       run: |
  #         echo "Application deployed with image: ${{ needs.build.outputs.image-tag }}"
  #         echo "Deployment timestamp: $(date)"

  # Stage 9: Health Check
  # healthcheck:
  #   name: Health Check
  #   runs-on: ubuntu-latest
  #   needs: deploy
  #   if: github.ref == 'refs/heads/main'
  #   steps:
  #     - name: Wait for deployment
  #       run: sleep 60

  #     - name: Health Check
  #       run: |
  #         # Replace with your actual application URL
  #         APP_URL="${{ secrets.APP_URL }}"
          
  #         echo "Performing health check on: $APP_URL"
          
  #         # Basic HTTP health check
  #         for i in {1..5}; do
  #           if curl -f -s "$APP_URL/health" > /dev/null; then
  #             echo "✅ Health check passed"
  #             break
  #           else
  #             echo "❌ Health check failed (attempt $i/5)"
  #             if [ $i -eq 5 ]; then
  #               echo "Health check failed after 5 attempts"
  #               exit 1
  #             fi
  #             sleep 10
  #           fi
  #         done

  #     - name: Performance Check
  #       run: |
  #         APP_URL="${{ secrets.APP_URL }}"
          
  #         # Basic performance check using curl
  #         RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "$APP_URL")
  #         echo "Response time: ${RESPONSE_TIME}s"
          
  #         # Fail if response time is greater than 5 seconds
  #         if (( $(echo "$RESPONSE_TIME > 5.0" | bc -l) )); then
  #           echo "❌ Performance check failed - Response time too slow"
  #           exit 1
  #         else
  #           echo "✅ Performance check passed"
  #         fi

  #     - name: Smoke Tests
  #       run: |
  #         APP_URL="${{ secrets.APP_URL }}"
          
  #         # Add smoke tests for critical functionality
  #         echo "Running smoke tests..."
          
  #         # Example smoke tests
  #         # Test login page loads
  #         if curl -f -s "$APP_URL/login" > /dev/null; then
  #           echo "✅ Login page accessible"
  #         else
  #           echo "❌ Login page not accessible"
  #           exit 1
  #         fi
          
  #         # Test API endpoint
  #         if curl -f -s "$APP_URL/api/health" > /dev/null; then
  #           echo "✅ API health endpoint accessible"
  #         else
  #           echo "❌ API health endpoint not accessible"
  #           exit 1
  #         fi
          
  #         echo "✅ All smoke tests passed"

  # Notification job (runs always at the end)
  # notify:
  #   name: Notify
  #   runs-on: ubuntu-latest
  #   # needs: [sast-scan, code-linting, docker-linting, build, image-scan, unit-tests, integration-tests, deploy, healthcheck]
  #   needs: [sast-scan, code-linting, docker-linting, build, image-scan, unit-tests]
  #   if: always()
  #   steps:
  #     - name: Notify Success
  #       if: ${{ !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
  #       run: |
  #         echo "🎉 Pipeline completed successfully!"
          
  #         # Discord webhook notification for success
  #         # Uncomment and configure the following section:
  #         # DISCORD_WEBHOOK_URL="${{ secrets.DISCORD_WEBHOOK_URL }}"
  #         # 
  #         # if [ -n "$DISCORD_WEBHOOK_URL" ]; then
  #         #   # Get commit info
  #         #   COMMIT_MSG=$(git log -1 --pretty=format:"%s" 2>/dev/null || echo "No commit message")
  #         #   COMMIT_AUTHOR=$(git log -1 --pretty=format:"%an" 2>/dev/null || echo "${{ github.actor }}")
  #         #   COMMIT_URL="https://github.com/${{ github.repository }}/commit/${{ github.sha }}"
  #         #   
  #         #   # Determine if this is a PR or push
  #         #   if [ "${{ github.event_name }}" = "pull_request" ]; then
  #         #     PR_NUMBER="${{ github.event.pull_request.number }}"
  #         #     PR_TITLE="${{ github.event.pull_request.title }}"
  #         #     PR_URL="https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
  #         #     EVENT_TYPE="Pull Request #$PR_NUMBER"
  #         #     EVENT_TITLE="$PR_TITLE"
  #         #     EVENT_URL="$PR_URL"
  #         #   else
  #         #     EVENT_TYPE="Push to ${{ github.ref_name }}"
  #         #     EVENT_TITLE="$COMMIT_MSG"
  #         #     EVENT_URL="$COMMIT_URL"
  #         #   fi
  #         #   
  #         #   # Create Discord embed payload
  #         #   DISCORD_PAYLOAD=$(cat <<EOF
  #         # {
  #         #   "username": "Vallena CI/CD",
  #         #   "avatar_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
  #         #   "embeds": [
  #         #     {
  #         #       "title": "✅ Pipeline Success",
  #         #       "description": "All stages completed successfully!",
  #         #       "color": 65280,
  #         #       "fields": [
  #         #         {
  #         #           "name": "Repository",
  #         #           "value": "${{ github.repository }}",
  #         #           "inline": true
  #         #         },
  #         #         {
  #         #           "name": "Event",
  #         #           "value": "$EVENT_TYPE",
  #         #           "inline": true
  #         #         },
  #         #         {
  #         #           "name": "Branch",
  #         #           "value": "${{ github.ref_name }}",
  #         #           "inline": true
  #         #         },
  #         #         {
  #         #           "name": "Commit",
  #         #           "value": "[\`${{ github.sha }}\`]($COMMIT_URL)",
  #         #           "inline": true
  #         #         },
  #         #         {
  #         #           "name": "Author",
  #         #           "value": "$COMMIT_AUTHOR",
  #         #           "inline": true
  #         #         },
  #         #         {
  #         #           "name": "Workflow",
  #         #           "value": "[${{ github.workflow }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})",
  #         #           "inline": true
  #         #         }
  #         #       ],
  #         #       "footer": {
  #         #         "text": "Vallena Web",
  #         #         "icon_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
  #         #       },
  #         #       "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)"
  #         #     }
  #         #   ]
  #         # }
  #         # EOF
  #         #   )
  #         #   
  #         #   # Send notification to Discord
  #         #   curl -H "Content-Type: application/json" \
  #         #        -d "$DISCORD_PAYLOAD" \
  #         #        "$DISCORD_WEBHOOK_URL"
  #         #   
  #         #   echo "Discord notification sent successfully"
  #         # else
  #         #   echo "Discord webhook URL not configured"
  #         # fi

  #     - name: Notify Failure
  #       if: ${{ contains(needs.*.result, 'failure') || contains(needs.*.result, 'cancelled') }}
  #       run: |
  #         echo "❌ Pipeline failed!"
          
  #         # Discord webhook notification for failure
  #         # Uncomment and configure the following section:
  #         # DISCORD_WEBHOOK_URL="${{ secrets.DISCORD_WEBHOOK_URL }}"
  #         # 
  #         # if [ -n "$DISCORD_WEBHOOK_URL" ]; then
  #         #   # Get commit info
  #         #   COMMIT_MSG=$(git log -1 --pretty=format:"%s" 2>/dev/null || echo "No commit message")
  #         #   COMMIT_AUTHOR=$(git log -1 --pretty=format:"%an" 2>/dev/null || echo "${{ github.actor }}")
  #         #   COMMIT_URL="https://github.com/${{ github.repository }}/commit/${{ github.sha }}"
  #         #   
  #         #   # Determine if this is a PR or push
  #         #   if [ "${{ github.event_name }}" = "pull_request" ]; then
  #         #     PR_NUMBER="${{ github.event.pull_request.number }}"
  #         #     PR_TITLE="${{ github.event.pull_request.title }}"
  #         #     PR_URL="https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
  #         #     EVENT_TYPE="Pull Request #$PR_NUMBER"
  #         #     EVENT_TITLE="$PR_TITLE"
  #         #     EVENT_URL="$PR_URL"
  #         #   else
  #         #     EVENT_TYPE="Push to ${{ github.ref_name }}"
  #         #     EVENT_TITLE="$COMMIT_MSG"
  #         #     EVENT_URL="$COMMIT_URL"
  #         #   fi
  #         #   
  #         #   # Determine which jobs failed
  #         #   FAILED_JOBS=""
  #         #   if [ "${{ needs.sast-scan.result }}" = "failure" ]; then FAILED_JOBS="$FAILED_JOBS• SAST Scan\n"; fi
  #         #   if [ "${{ needs.code-linting.result }}" = "failure" ]; then FAILED_JOBS="$FAILED_JOBS• Code Linting\n"; fi
  #         #   if [ "${{ needs.docker-linting.result }}" = "failure" ]; then FAILED_JOBS="$FAILED_JOBS• Docker Linting\n"; fi
  #         #   if [ "${{ needs.build.result }}" = "failure" ]; then FAILED_JOBS="$FAILED_JOBS• Build\n"; fi
  #         #   if [ "${{ needs.image-scan.result }}" = "failure" ]; then FAILED_JOBS="$FAILED_JOBS• Image Scan\n"; fi
  #         #   if [ "${{ needs.unit-tests.result }}" = "failure" ]; then FAILED_JOBS="$FAILED_JOBS• Unit Tests\n"; fi
  #         #   if [ "${{ needs.integration-tests.result }}" = "failure" ]; then FAILED_JOBS="$FAILED_JOBS• Integration Tests\n"; fi
  #         #   if [ "${{ needs.deploy.result }}" = "failure" ]; then FAILED_JOBS="$FAILED_JOBS• Deploy\n"; fi
  #         #   if [ "${{ needs.healthcheck.result }}" = "failure" ]; then FAILED_JOBS="$FAILED_JOBS• Health Check\n"; fi
  #         #   
  #         #   # Remove trailing newline if any
  #         #   FAILED_JOBS=$(echo -e "$FAILED_JOBS" | sed '/^$/d')
  #         #   
  #         #   # Create Discord embed payload for failure
  #         #   DISCORD_PAYLOAD=$(cat <<EOF
  #         # {
  #         #   "username": "Vallena CI/CD",
  #         #   "avatar_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
  #         #   "embeds": [
  #         #     {
  #         #       "title": "❌ Pipeline Failed",
  #         #       "description": "One or more stages failed during execution",
  #         #       "color": 16711680,
  #         #       "fields": [
  #         #         {
  #         #           "name": "Repository",
  #         #           "value": "${{ github.repository }}",
  #         #           "inline": true
  #         #         },
  #         #         {
  #         #           "name": "Event",
  #         #           "value": "$EVENT_TYPE",
  #         #           "inline": true
  #         #         },
  #         #         {
  #         #           "name": "Branch",
  #         #           "value": "${{ github.ref_name }}",
  #         #           "inline": true
  #         #         },
  #         #         {
  #         #           "name": "Commit",
  #         #           "value": "[\`${{ github.sha }}\`]($COMMIT_URL)",
  #         #           "inline": true
  #         #         },
  #         #         {
  #         #           "name": "Author",
  #         #           "value": "$COMMIT_AUTHOR",
  #         #           "inline": true
  #         #         },
  #         #         {
  #         #           "name": "Failed Jobs",
  #         #           "value": "$FAILED_JOBS",
  #         #           "inline": false
  #         #         },
  #         #         {
  #         #           "name": "Workflow",
  #         #           "value": "[${{ github.workflow }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})",
  #         #           "inline": false
  #         #         }
  #         #       ],
  #         #       "footer": {
  #         #         "text": "Vallena Web",
  #         #         "icon_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
  #         #       },
  #         #       "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)"
  #         #     }
  #         #   ]
  #         # }
  #         # EOF
  #         #   )
  #         #   
  #         #   # Send notification to Discord
  #         #   curl -H "Content-Type: application/json" \
  #         #        -d "$DISCORD_PAYLOAD" \
  #         #        "$DISCORD_WEBHOOK_URL"
  #         #   
  #         #   echo "Discord notification sent successfully"
  #         # else
  #         #   echo "Discord webhook URL not configured"
  #         # fi
